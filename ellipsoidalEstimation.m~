function [ output_args ] = ellipsoidalEstimation(mode, precision, tEst, vec1, vec2,...
    n, A, B, xVec, xMat, pVec, pMat)
% Main function that estimate reachability set using inner and outer 
%   ellipsoids. After that it project set onto plane, dynamic or static.
% List of parameters:
%   mode - mode of program:
%       "2d" - in this mode reach set at time tEst(1) (tEst(2) will be
%       ignored if exists!) is projected at plane (vec1, vec2).
%       "static3d" - in this mode a projection of reach tube is builded.
%       Projection onto plane (vec1, vec2), no "good" lines used. Time
%       interval is [tEst(1), tEst(2)]
%       "dynamic3d" - in this mode a projection of reach tube is builded.
%       Projection onto  plane (vec1, vec2), changing dynamically so that "good" lines keep being tangent. 
%       Time interval is [tEst(1), tEst(2)]
%   precision ? parameter for splitting approximation directions
%   tEst - estimation time, positive. Can contain 1 or 2 elements.
%   vec1, vec2 - vectors for projection plane.
%   n - parameter for splitting time interval for tube modes.
%   A, B, xVec, xMat - constant parameters, determing.
%       differential equation dx/dt = Ax + Bu with start set as ellipsoid
%       E(xVec, xMat). Make sure that all dimensions are OK.
%   pVec(t), pMat(t) - equation parameters, determing dynamic ellipsoid 
%       E(pVec(t), pMat(t)) for control limits.
%   ellipsoidalEstimation(mode, tEst, vec1, vec2, n, A, B, xVec, xMat, pVec, pMat)    
    
%mode check
    switch mode
        case {'2d'}
            tEst = tEst(1);
            %2d proj func
            Estimation2d( precision, tEst, vec1, vec2, n, ...
                A, B, xVec, xMat, pVec, pMat )
            disp('2d');
        case {'static3d'}
            disp('static3d');
            %static 3d proj func
        case {'dynamic3d'}
            disp('dynamic3d');
            %dynamic 3d 
        otherwise
            disp('Invalid mode!');
            return;
    end;
    
    %dimension check
    sizeA = size(A);
    sizeB = size(B);
    sizeXMat = size(xMat);
    sizeXVec = size(xVec);
    sizePMat = size(pMat);
    sizePVec = size(pVec);
    %firstly, we have to assume that xVec and uVec are vector-columns
    if (min(sizeXVec) ~= 1)
        disp('xVec is not a vector!');
        return;
    end;
    if (min(sizeUVec) ~= 1)
        disp('uVec is not a vector!');
        return;
    end;
    if (sizeXVec(1) == 1)
        xVec = xVec';
    end;
    if (sizeUVec(1) == 1)
        uVec = uVec';
    end;
    sizeX = max(sizeXVec);
    sizeU = max(sizeUVec);
    if (sizeA(1) ~= sizeA(2))
        disp('A is not square!');
        return;
    end;
    if ( sizeX ~= sizeA(1); % X dimension check
   
    if (sizeB(1) ~= sizeA)
        disp('Sizes of B and A do not agree!');
        return;
    end;
    sizeU = sizeB(2); % U dimension size
end

